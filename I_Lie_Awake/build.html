<html>
<style>
body {
	text-align:center;
	background:#000;
	color:#fff;
}
</style>
<script>
var modCache = {};
var mods = {
'sald:mainloop.js' : function(module) {
if (typeof(window.sald) === "undefined") {
	window.sald = {};
}

//Just 'require'-ing this file installs several useful global properties:
window.sald.scene = {}; //the current scene; update, draw, scrollWheel,  and key functions will be called.
window.sald.ctx = null; //the drawing context, call canvas 2d functions here
window.sald.size = {x:320, y:240, mode:"exact"}; //set your desired size here
window.sald.keys = {}; //all keys currently held down (named by strings below)
window.sald.mouse = null; //mouse information {x:, y:, buttons:}
window.sald.takeRightClickInput = true; //should right mouse button trigger events?

var keyNameToCode = {
	"BACKSPACE": 8,
	"TAB": 9,
	"ENTER": 13,
	"SHIFT": 16,
	"CONTROL": 17,
	"ALT": 18,
	"PAUSE": 19,
	"CAPS_LOCK": 20,
	"ESCAPE": 27,
	"SPACE": 32,
	"PAGE_UP": 33,
	"PAGE_DOWN": 34,
	"END": 35,
	"HOME": 36,
	"LEFT": 37,
	"UP": 38,
	"RIGHT": 39,
	"DOWN": 40,
	"INSERT": 45,
	"DELETE": 46,
	"ZERO": 48,
	"ONE": 49,
	"TWO": 50,
	"THREE": 51,
	"FOUR": 52,
	"FIVE": 53,
	"SIX": 54,
	"SEVEN": 55,
	"EIGHT": 56,
	"NINE": 57,
	"A": 65,
	"B": 66,
	"C": 67,
	"D": 68,
	"E": 69,
	"F": 70,
	"G": 71,
	"H": 72,
	"I": 73,
	"J": 74,
	"K": 75,
	"L": 76,
	"M": 77,
	"N": 78,
	"O": 79,
	"P": 80,
	"Q": 81,
	"R": 82,
	"S": 83,
	"T": 84,
	"U": 85,
	"V": 86,
	"W": 87,
	"X": 88,
	"Y": 89,
	"Z": 90,
	"WINDOWS": 91,
	"NUMPAD_0": 96,
	"NUMPAD_1": 97,
	"NUMPAD_2": 98,
	"NUMPAD_3": 99,
	"NUMPAD_4": 100,
	"NUMPAD_5": 101,
	"NUMPAD_6": 102,
	"NUMPAD_7": 103,
	"NUMPAD_8": 104,
	"NUMPAD_9": 105,
	"NUMPAD_ASTERISK": 106,
	"NUMPAD_MULTIPLY": 107,
	"NUMPAD_MINUS": 109,
	"NUMPAD_PERIOD": 110,
	"NUMPAD_DIVIDE": 111,
	"F1": 112,
	"F2": 113,
	"F3": 114,
	"F4": 115,
	"F5": 116,
	"F6": 117,
	"F7": 118,
	"F8": 119,
	"F9": 120,
	"F10": 121,
	"F11": 122,
	"F12": 123,
	"NUM_LOCK": 144,
	"SCROLL_LOCK": 145,
	"MY_COMPUTER": 182,
	"MY_CALCULATOR": 183,
	"SEMICOLON": 186,
	"EQUALS": 187,
	"COMMA": 188,
	"MINUS": 189,
	"PERIOD": 190,
	"FORWARD_SLASH": 191,
	"TILDE": 192,
	"OPEN_BRACKET": 219,
	"BACK_SLASH": 220,
	"CLOSE_BRACKET": 221,
	"APOSTROPHE": 222
};

var buttonNameToCode = {
	//there is also -1 === 'no button'
	"LEFT" : 0,
	"MIDDLE" : 1,
	"RIGHT" : 2,
	"BACK" : 3,
	"FORWARD" : 4
};

function generateCodeToName(nameToCode){
	// stringToCode maps from strings to integer values
	var array = [];

	for (var name in nameToCode){
		array[nameToCode[name]] = name;
	}

	return function (i) {
		return array[i];
	}
}

var keyCodeToName = generateCodeToName(keyNameToCode);

var buttonToName = generateCodeToName(buttonNameToCode);

//This function sets up the main loop:
function start(canvas, options) {

	if (typeof(options) === "undefined") {
		options = {};
	}
	
	var sald = window.sald; //redundant, probably

	//------------ create context --------------

	if (options.gl) {
		window.sald.gl = canvas.getContext('webgl', options.gl) || canvas.getContext("experimental-webgl", options.gl);
	} else {
		window.sald.ctx = canvas.getContext('2d');
	}

	//----------- handle init --------------
	//  (used by meshes and shaders that require a gl context to load)
	if (window.sald.initFuncs) {
		window.sald.initFuncs.forEach(function(f){ f(); });
	}

	//------------ handle canvas sizing --------------

	var currentFactor = -1;

	function resized() {
		var parent = canvas.parentNode;
		var parentStyle = getComputedStyle(parent);
		var maxSize = {width:parent.clientWidth, height:parent.clientHeight};
		maxSize.width -= parseInt(parentStyle.getPropertyValue("padding-left")) + parseInt(parentStyle.getPropertyValue("padding-right"));
		maxSize.height -= parseInt(parentStyle.getPropertyValue("padding-top")) + parseInt(parentStyle.getPropertyValue("padding-bottom"));

		var factor;

		if (typeof(sald.size.mode) === "undefined" || sald.size.mode === "exact") {
			factor = 1;
		} else if (sald.size.mode === "multiple") {
			factor = Math.floor(Math.min(maxSize.width / sald.size.x, maxSize.height / sald.size.y)) | 0;
			factor = Math.max(1, factor);
		} else if (sald.size.mode === "ratio") {
			factor = Math.min(maxSize.width / sald.size.x, maxSize.height / sald.size.y);
			factor = Math.max(1, factor);
		}

		if (factor != currentFactor) {
			currentFactor = factor;

			var width = Math.round(sald.size.x * factor);
			var height = Math.round(sald.size.y * factor);

			//actually set canvas size:
			//   ...both the display size:
			canvas.style.width = width + "px";
			canvas.style.height = height + "px";
			//   ...and the actual pixel count:
			canvas.width = width;
			canvas.height = height;

			//store the information into the drawing context for other code:
			if (sald.ctx) {
				sald.ctx.width = width;
				sald.ctx.height = height;
				sald.ctx.factor = factor;
			} else {
				sald.gl.width = width;
				sald.gl.height = height;
				sald.gl.factor = factor;
			}
		}
	}

	//install 'resized' to handle window resize events:
	window.addEventListener('resize', resized);
	//also call it now to set up a good initial size:
	resized();


	// -----------------------
	// ----- Main Loop -------
	// -----------------------
	var previous = NaN;
	function render(timestamp) {
		if (isNaN(previous)) {
			previous = timestamp;
		}
		var elapsed = (timestamp - previous) / 1000.0;
		previous = timestamp;

		if(elapsed > .1) elapsed = .1;
		
		sald.scene && sald.scene.update && sald.scene.update(elapsed);
		sald.scene && sald.scene.draw && sald.scene.draw();

		window.requestAnimationFrame(render);
	};

	window.requestAnimationFrame(render);


	//------- key handlers -------

	window.addEventListener('keydown', function(evt){
		var keyName =  keyCodeToName(evt.keyCode);

		var keydownsToIgnorePreventingDefault = {
			 "WINDOWS" : true,
			 "CONTROL" : true
			};

		if (sald.keys.hasOwnProperty(keyName)) {
			//already handled this keydown
		} else {
			sald.keys[keyName] = true;
			sald.scene && sald.scene.key && sald.scene.key(keyName, true);
		}

		// TODO figure out which keys to prevent default, and when
		if (!(keyName in keydownsToIgnorePreventingDefault)){
			if (!(("WINDOWS" in sald.keys && sald.keys["WINDOWS"]) ||
					"CONTROL" in sald.keys && sald.keys["CONTROL"])){
				evt.preventDefault();
			}
		}
		return false;
	});
	
	window.addEventListener('keyup', function(evt){
		var keyName =  keyCodeToName(evt.keyCode);

		if (sald.keys.hasOwnProperty(keyName)) {
			delete sald.keys[keyName];
			sald.scene && sald.scene.key && sald.scene.key(keyName, false);
		}
		
		evt.preventDefault();
		return false;
	});


	//------- mouse handlers -------
	
	// suppress context menu on right click:
	window.addEventListener('contextmenu', function(evt) {
		if (window.sald.takeRightClickInput){
	    	evt.preventDefault();
			return false;
		}
	});

	//helper: update mouse object
	function setMouse(evt) {
		var rect = canvas.getBoundingClientRect();

		//The '0.5' additions here seem to align a '+' drawn at the cursor
		//  position to the cursor better, but I'm not sure why:
		var x = (evt.clientX + 0.5 - rect.left);
		var y = (evt.clientY + 0.5 - rect.top);

		var buttons = {};
		for (var name in buttonNameToCode) {
			if (name === "RIGHT" && !window.sald.takeRightClickInput) {
				//skip right button, if flag isn't set
			} else {
				if (evt.buttons & (1 << buttonNameToCode[name])) {
					buttons[name] = true;
				}
			}
		}

		window.sald.mouse = {x:x, y:y, buttons:buttons};
	}

	window.addEventListener('mousedown', function(evt) {
		setMouse(evt);

		var buttonName = buttonToName(evt.button);

		//if we don't have a name for this button, don't handle it:
		if (buttonName === undefined) {
			return;
		}

		//if this is a right click, and we're not set to handle those, don't handle it:
		if (buttonName === "RIGHT" && !window.sald.takeRightClickInput){
			return;
		}

		sald.scene && sald.scene.mouse && sald.scene.mouse({x:sald.mouse.x, y:sald.mouse.y}, buttonName, true);

		evt.preventDefault();
		return false;
	});


	window.addEventListener('mouseup', function (evt) {
		setMouse(evt);

		var buttonName = buttonToName(evt.button);

		//if we don't have a name for this button, don't handle it:
		if (buttonName === undefined) {
			return;
		}

		//if this is a right click, and we're not set to handle those, don't handle it:
		if (buttonName === "RIGHT" && !window.sald.takeRightClickInput){
			return;
		}

		sald.scene && sald.scene.mouse && sald.scene.mouse({x:sald.mouse.x, y:sald.mouse.y}, buttonName, false);

		evt.preventDefault();
		return false;
	});

	window.addEventListener('mousemove', function (evt) {
		setMouse(evt);

		sald.scene && sald.scene.mouse && sald.scene.mouse({x:sald.mouse.x, y:sald.mouse.y});

		evt.preventDefault();
		return false;		
	});
	
	//------- wheel handler -------

	window.addEventListener('wheel', function (evt) {
		if (!(sald.scene && sald.scene.wheel)) return;

		var delta = {
			x:evt.deltaX,
			y:evt.deltaY,
			z:evt.deltaZ
		};

		//At some point, we should figure out how to adjust the delta based on its mode:
		if (evt.deltaMode === 0) { //"pixels"
		} else if (evt.deltaMode === 1) { //"lines"
		} else if (evt.deltaMode === 2) { //"pages"
		}

		sald.scene && sald.scene.wheel && sald.scene.wheel(delta);

		evt.preventDefault();
		return false;
	});

	//---------------------------------
};


module.exports = {
	start:start
};
},
'/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/camera.js' : function(module) {
var utils = require("/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/utils.js")

var camera = {
	x : utils.halfScreenWidth(),
	y : utils.halfScreenHeight()
};

var room = {
	width : 500,
	height : 400
}

var update = function(elapsed, movementTransform){
	var halfScreenWidth = utils.halfScreenWidth()
	var halfScreenHeight = utils.halfScreenHeight();

	if (movementTransform.x > halfScreenWidth &&
		movementTransform.x < room.width - halfScreenWidth){
		camera.x = movementTransform.x;
	}

	if (movementTransform.y > halfScreenHeight &&
		movementTransform.y < room.height - halfScreenHeight){
		camera.y = movementTransform.y;
	}
}

var topLeftCorner = function(){
	return {
		x : camera.x - utils.halfScreenWidth(),
		y : camera.y - utils.halfScreenHeight()
	};
}

module.exports = {
	transform:camera,
	update:update,
	topLeftCorner:topLeftCorner
};},
'/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/utils.js' : function(module) {
function sign(x) { return x ? x < 0 ? -1 : 1 : 0; }

var HALF_SCREEN_WIDTH = (sald.size.x/2);
var HALF_SCREEN_HEIGHT = (sald.size.y/2);

var halfScreenWidth = function(){
	return HALF_SCREEN_WIDTH;
}

var halfScreenHeight = function(){
	return HALF_SCREEN_HEIGHT;
}

module.exports = {
	sign:sign,
	halfScreenWidth:halfScreenWidth,
	halfScreenHeight:halfScreenHeight
};},
'/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/MainCharacter.js' : function(module) {
var movement = require("/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/movement.js");
var GameObject = require("/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/GameObject.js").GameObject;

var startX = sald.size.x/2;
var startY = sald.size.y/2;
var width  = 16;
var height = 30;

function MainCharacter(){
	GameObject.call(this, startX, startY, width, height);

	movement.initialize(this);
}

MainCharacter.prototype = Object.create(GameObject.prototype);

MainCharacter.prototype.constructor = MainCharacter;

MainCharacter.prototype.movement = movement;


module.exports = {
	MainCharacter:MainCharacter
};},
'/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/movement.js' : function(module) {
var camera = require("/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/camera.js");
var utils = require("/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/utils.js");
var GameObject = require("/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/GameObject.js").GameObject;

var character;

var Vector = function(x, y){
	this.x = x;
	this.y = y;
	this.length = Math.sqrt((x*x) + (y*y));
	this.angle = Math.acos( x / this.length );
}

var getTheta = function(xDelta, yDelta){
	var vec = new Vector(xDelta, yDelta);

	return vec.angle;
}

var initialize = function(gameObj){
	character = gameObj;

	var width  = gameObj.getWidth();
	var height = gameObj.getHeight();

	setupTransform(68, 50, width, height);
}

function sign(x) { return x ? x < 0 ? -1 : 1 : 0; }

// xDelta and yDelta pixels per second
var setupTransform = function(xDelta, yDelta, width, height){
	var transform = character.transform;

	transform.xDelta = xDelta;
	transform.yDelta = yDelta;

	transform.halfHeight = height / 2;
	transform.halfWidth = width / 2;

	transform.width = width;
	transform.height = height;
	
	var theta = getTheta(xDelta, yDelta);

	transform.xDiag = Math.cos(theta) * transform.xDelta;
	transform.yDiag = Math.sin(theta) * transform.yDelta;
}

var update = function(elapsed){
	var keys = sald.keys;

	var rightness = 0;
	var downness = 0;
	
	var transform = character.transform;

	// Measure input
	if (keys.LEFT  || keys.A){rightness -= transform.xDelta;}
	if (keys.RIGHT || keys.D){rightness += transform.xDelta;}
	if (keys.UP    || keys.W){downness  -= transform.yDelta;}
	if (keys.DOWN  || keys.S){downness  += transform.yDelta;}

	// Compute movement if there should be some
	if (rightness !== 0 || downness !== 0) {
		// Unit circle the input, avoiding "fast diagonal movement"
		if (rightness !== 0 && downness !== 0){
			rightness = utils.sign(rightness) * transform.xDiag;
			downness = utils.sign(downness) * transform.yDiag;
		}

		var xDelta = rightness * elapsed;
		var yDelta = downness * elapsed;

		// Collision check
		transform.x += xDelta;
		transform.y += yDelta;

		// Camera updates on movement
		camera.update(elapsed, transform);
	};
}

module.exports = {
	update:update,
	initialize:initialize
};},
'/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/GameObject.js' : function(module) {
var collision = require("sald:collide.js");

var GameObject = function(x_, y_, width_, height_){

	var width = width_;
	var height = height_;

	var halfWidth  = width  / 2;
	var halfHeight = height / 2;

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.setWidth = function(num){
		width = num;
		halfWidth = width / 2;
	}

	this.setHeight = function(num){
		height = num;
		halfHeight = height / 2;
	}

	this.halfWidth = function() {
		return halfWidth;
	}

	this.halfHeight = function() {
		return halfHeight;
	}

	this.transform = {
		x : x_,
		y : y_
	};

	// For collisions
	this.relativeBoundingBox = {
		min : {
			x : 0,
			y : 0
		},
		max : {
			x : width,
			y : height
		}
	}
}

GameObject.prototype.collisionBox = function() {
	var bb = this.relativeBoundingBox;
	var min_ = {x : this.x + bb.min.x,
				y : this.y + bb.min.y};
	var max_ = {	
		x : min_.x + bb.max.x,
		y : min_.y + bb.max.y 
	}
	return {
		min : min_,
		max : max_
	};
};

GameObject.prototype.isColliding = function(obj2){
	var rect2 = obj2.collisionBox();

	return collision.rectangleRectangle(this.collisionBox(), rect2);
};

module.exports = {
	GameObject:GameObject,
};},
'sald:collide.js' : function(module) {
/* Circle vs Circle
 * INPUT: two circles specified by position and radius:
 *  c1 = {x:, y:, r:}, c2 = {x:, y:, r:}
 * RETURN VALUE:
 *  false if c1 and c2 do not intersect
 *  true if c1 and c2 do intersect
 */
function circleCircle(c1,c2) {
    var rsum = c1.r + c2.r;
    var dx = c1.x - c2.x;
    var dy = c1.y - c2.y;
    var distsq = dx*dx + dy*dy
    
    return rsum*rsum > distsq;
}

/* Rectangle vs Rectangle
 * INPUT: rectangles specified by their minimum and maximum extents:
 *  r = {min:{x:, y:}, max:{x:, y:}}
 * RETURN VALUE:
 *  false if r1 and r2 do not intersect
 *  true if r1 and r2 do intersect
 */
function rectangleRectangle(r1, r2) {
    return r1.min.x < r2.max.x  // no gap in [r2.max.x,r1.min.x]
        && r2.min.x < r1.max.x  // no gap in [r1.max.x,r2.min.x]
        && r1.min.y < r2.max.y  // no gap in [r2.max.y,r1.min.y]
        && r2.min.y < r1.max.y; // no gap in [r1.max.y,r2.min.y]
}

/* Convex vs Convex
 * INPUT: convex polygons as lists of vertices in CCW order
 *  p = [{x:,y:}, ..., {x:, y:}]
 * RETURN VALUE:
 *  false if p1 and p2 do not intersect
 *  true if p1 and p2 do intersect
 */
function convexConvex(p1, p2) {
    return convexConvexHelper(p1, p2) && convexConvexHelper(p2, p1)
}

function convexConvexHelper(p1, p2) {
    for (var i = 0; i < p1.length; i++) {
        var x1 = p1[i].x;
        var y1 = p1[i].y;
        
        var x2 = p1[(i+1) % p1.length].x;
        var y2 = p1[(i+1) % p1.length].y;
        
        var x3 = p1[(i+2) % p1.length].x;
        var y3 = p1[(i+2) % p1.length].y;
        
        var p1Side = lineSide(x1, y1, x2, y2, x3, y3);
        var p2Side = 0;
        
        for (var j = 0; j < p2.length; j++) {
            var p2x = p2[j].x;
            var p2y = p2[j].y;
            
            p2Side = lineSide(x1, y1, x2, y2, p2x, p2y);
            if (p1Side == p2Side) {
                break;
            }
        }
        
        if (p1Side != p2Side) {
            return false;
        }
    }
    
    return true;
}

function lineSide(x1, y1, x2, y2, px, py) {
    return Math.sign((x1-x2)*(py-y1) - (y1-y2)*(px-x1));
}

/* Rav vs Circle
 * INPUT: ray specified as a start and end point, circle as above.
 *  ray = {start:{x:, y:}, end:{x:, y:}}
 * RETURN VALUE:
 *  null if no intersection
 *  {t:} if intersection
 *    -- NOTE: 0.0 <= t <= 1.0 gives the position of the first intersection
 */
function rayCircle(r, c) {
    // Reference: http://math.stackexchange.com/questions/311921/get-location-of-vector-circle-intersection
    var ray_dx = r.end.x - r.start.x;
    var ray_dy = r.end.y - r.start.y;
    var A = ray_dx * ray_dx + ray_dy * ray_dy;
    
    var rel_circlex = r.start.x - c.x;
    var rel_circley = r.start.y - c.y;
    
    
    var B = 2 * (ray_dx * rel_circlex + ray_dy * rel_circley);
    var C = rel_circlex * rel_circlex + rel_circley * rel_circley - c.r * c.r;

    var discriminant = B * B - 4 * A * C;
    
    if (discriminant < 0) {
        return null;
    }
    else {
        var T = (-B - Math.sqrt(discriminant))/(2*A)
        var T2 = (-B + Math.sqrt(discriminant))/(2*A);
        
        if (T > 0 && T < 1) {
            return {t:T};
        }
        else if (T2 > 0 && T2 < 1) {
            return {t:T2};
        }
    }
    return null;
}

/* Rav vs Rectangle
 * INPUT: ray as above, rectangle as above.
 * RETURN VALUE:
 *  null if no intersection
 *  {t:} if intersection
 *    -- NOTE: 0.0 <= t <= 1.0 gives the position of the first intersection
 */
function rayRectangle(r, b) {
    var dx = r.end.x - r.start.x;
    var dy = r.end.y - r.start.y;
    var minx = b.min.x - r.start.x;
    var miny = b.min.y - r.start.y;
    var maxx = b.max.x - r.start.x;
    var maxy = b.max.y - r.start.y;

    var tx1 = minx / dx;
    var tx2 = maxx / dx;
    var ty1 = miny / dy;
    var ty2 = maxy / dy;

    var txmin = Math.min(tx1,tx2);
    var txmax = Math.max(tx1,tx2);
    var tymin = Math.min(ty1,ty2);
    var tymax = Math.max(ty1,ty2);

    var min = Math.max(txmin,tymin);
    var max = Math.min(txmax,tymax);
    if(min < max && min <= 1 && max >= 0) {
        return {t: Math.max(0,min)};
    }
    else {
        return null;
    }
}

/* Rav vs Convex
 * INPUT: ray as above, convex polygon as above.
 * RETURN VALUE:
 *  null if no intersection
 *  {t:} if intersection
 *    -- NOTE: 0.0 <= t <= 1.0 gives the position of the first intersection
 */
/* Rav vs Convex
 * INPUT: ray as above, convex polygon as above.
 * RETURN VALUE:
 *  null if no intersection
 *  {t:} if intersection
 *    -- NOTE: 0.0 <= t <= 1.0 gives the position of the first intersection
 */
function rayConvex(r, p) {
    var ray_dx = r.end.x - r.start.x;
    var ray_dy = r.end.y - r.start.y;
    var T_enter = Number.NEGATIVE_INFINITY;
    var T_exit = Number.POSITIVE_INFINITY;
    
    for (var i = 0; i < p.length; i++) {
        var startx = p[i].x;
        var starty = p[i].y;
        var endx = p[(i+1)%p.length].x;
        var endy = p[(i+1)%p.length].y;
        
        var norm_dx = starty - endy;
        var norm_dy = endx - startx;
        
        // Enter/exiting reference: http://geomalgorithms.com/a13-_intersect-4.html
        var dot = ray_dx * norm_dx + ray_dy * norm_dy;
        
        var slope = (endy - starty)/(endx - startx);
        
        var T_numerator = (r.start.x - startx) * slope + starty - r.start.y;
        var T_denominator = ray_dy - slope * ray_dx;
        
        var T_intersect = T_numerator / T_denominator;
        
        if (dot > 0) {
            if (T_intersect > T_enter) {
                T_enter = T_intersect;
            }
        }
        else {
            if (T_intersect < T_exit) {
                T_exit = T_intersect;
            }
        }
    }
    
    if (T_enter > T_exit) {
        return null;
    }
    
    if (T_enter > 0 && T_enter < 1) {
        return {t:T_enter};
    }
    else if (T_exit > 0 && T_exit < 1) {
        return {t:T_exit};
    }
    
    return null;
}


module.exports = {
    circleCircle: circleCircle,
    rectangleRectangle: rectangleRectangle,
    convexConvex: convexConvex,
    rayCircle: rayCircle,
    rayRectangle: rayRectangle,
    rayConvex: rayConvex
};
},
'/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/main.js' : function(module) {
var mainloop = require("sald:mainloop.js");
var camera = require("/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/camera.js");
var MainCharacter = require("/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/MainCharacter.js").MainCharacter;

function drawBackground() {
	var cameraCorner = camera.topLeftCorner();

	var ctx = sald.ctx;
	
	var d = new Date();
	var n = d.getMilliseconds();

	ctx.fillStyle = 'rgb(256, 256, 200)';

	ctx.fillRect(20, 20, ctx.width, 
			ctx.height);
	
	ctx.fillRect(0,0, ctx.width, ctx.height);

	ctx.fillStyle = 'rgb(200, 200, 256)';

	ctx.fillRect(200 - cameraCorner.x, 200 - cameraCorner.y, 
				400, 400);
}

// Not rescaleable
// sald.size = {x:320, y:240, mode:"exact"};

// Fully, dynamically rescalable
sald.size = {x:320, y:240, mode:"ratio"};

var mainCharacter = new MainCharacter();

// Exact aspect ratio, to match pixel art
// sald.size = {x:320, y:240, mode:"multiple"};

sald.scene = {
	/* Use elapsed to make sure that the framerate doesn't 
	 * affect the gameplay
	 */
	update:function(elapsed) {
		mainCharacter.movement.update(elapsed);
	},
	draw:function() {
		// Clear the screen
		var ctx = sald.ctx;

		var scalar = sald.ctx.factor;

		ctx.setTransform(scalar,0, 0,scalar, 0,0);
		ctx.clearRect( 0, 0, ctx.width, ctx.height );

		var cameraCorner = camera.topLeftCorner();

		// Draw Background
		drawBackground();

		// Draw the character
		var transform = mainCharacter.transform;

		ctx.fillStyle = 'rgb(256, 0, 0)';

		var onScreenPos = {
			x : transform.x - cameraCorner.x,
			y : transform.y - cameraCorner.y
		}

		ctx.fillRect(onScreenPos.x - mainCharacter.halfWidth(),
			onScreenPos.y - mainCharacter.halfHeight(),
			mainCharacter.getWidth(), 
			mainCharacter.getHeight());

		// Draw the foreground
	},
	key:function(key, down) {

		// if (key === "SPACE" && down) {
		// 	this.blink = 1.0;
		// }
	},
	mouse:function(pos, button, down) {
		//Mouse handling.
	},
};

window.main = function main() {
	mainloop.start(document.getElementById("canvas"));
};
}
}
function require(s) {
	if(modCache[s] == null) {
		modCache[s] = {exports:{}};
		mods[s](modCache[s]);
		return modCache[s].exports;
	} else {
		return modCache[s].exports;
	}
}
require("/Users/asweet/Documents/2014-2015 Senior/02 Spring/Experimental Animation/04 Final Project/child-in-war-game/I_Lie_Awake/src/main.js");

</script>
<body onload="main()">
<canvas id="canvas"></canvas>
</body>
</html>
